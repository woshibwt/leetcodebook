{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction   这是我刷leetcode的总结 "},"leetcode-94-二叉树的中序遍历.html":{"url":"leetcode-94-二叉树的中序遍历.html","title":"leetcode94 二叉树的中序遍历","keywords":"","body":"给定一个二叉树，返回它的中序 遍历。 示例: 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 递归法 首先最简单的方法当然是递归： class Solution { public List inorderTraversal(TreeNode root) { List res = new ArrayList<>(); helper(root,res); return res; } public void helper(TreeNode root,List res){ if(root!=null){ if(root.left!=null){ helper(root.left,res); } res.add(root.val); if(root.right!=null){ helper(root.right,res); } } } }b 在inorderTraversal函数中定义了一个Integer类型的List,通过递归helper()函数,在递归访问完当前节点的左右子树的中间将节点的值加入到List中。 迭代法  根据中序遍历的顺序，对于任一几点，优先访问其左孩子，而左孩子又可以看成一根节点，然后继续访问其左孩子节点，直到左孩子节点为空的节点才结束访问，然后按照同样的规则访问右子树。其处理过程如下： 对于任一节点curr:1)若其左孩子不为空，则将curr入栈并将它的左孩子置为新的curr,然后对新的curr执行新的处理2)若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点(res.add(curr.val))，然后将栈顶节点的右孩子置为新的curr3)直到curr为NULL和栈为空时结束。 class Solution { public List inorderTraversal(TreeNode root) { List res = new ArrayList<>(); Stack stack = new Stack <>(); TreeNode curr = root; while(curr!=null||!stack.isEmpty()){ while(curr != null){ stack.push(curr); curr = curr.left; } curr = stack.pop(); res.add(curr.val); curr = curr.right; } return res; } } ArrayList简单介绍  编程的时候存储多个数据时，长度固定的数组不一定能满足需求，此时选择集合，其提供了一种存储空间可变的存储模型，存储的数据容量可以改变，其中一个就是ArrayList。 ArrayList: 底层是可调整大小的数组实现 是特殊的数据类型，泛型。ArrayList构造方法和添加方法 ArrayList常用方法 "},"leetcode-95-不同的二叉搜索树 II.html":{"url":"leetcode-95-不同的二叉搜索树 II.html","title":"leetcode95 不同的二叉搜索树 II","keywords":"","body":"给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。 示例： 输入：3 输出： [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] 解释： 以上的输出对应以下 5 种不同结构的二叉搜索树 思考这个问题，我们先从锚定根节点，如何构建一棵二叉搜索树开始，然后进一步思考，在一个区间内遍历选择所有不同的根节点，并且将返回的节点装在列表中（left,right）,并且通过二层循环将两个列表中的节点依次放在当前root两边 构建一棵二叉搜索树 public TreeNode createBinaryTree(int n){ return helper(1, n); } public TreeNode helper(int start, int end){ if (start > end) return null; // 这里可以选择从start到end的任何一个值做为根结点， // 这里选择它们的中点，实际上，这样构建出来的是一颗平衡二叉搜索树 int val = (start + end) / 2; TreeNode root = new TreeNode(val); root.left = helper(start, val - 1); root.right = helper(val + 1, end); return root; } 在选择根节点时，可以不用取中点构造平衡二叉树，用遍历的方法也可 // 选择所有可能的根结点 for(int i = start; i 构建多棵二叉搜索树返回列表 在这道题中我们需要的是多棵树，可以将不同的根节点装入list后返回，可以将上述代码改写为： public List helper(int start, int end){ List list = new ArrayList<>(); if(start > end){ list.add(null); return list; } for(int i = start; i 如何构建root的左右子树 我们抛开复杂的递归函数，只关心递归的返回值，每次选择根结点root，我们 1.递归构建左子树，并拿到左子树所有可能的根结点列表left 2.递归构右子树，并拿到右子树所有可能的根结点列表right 这个时候我们有了左右子树列表，我们的左右子树都是各不相同的，因为根结点不同，我们如何通过左右子树列表构建出所有的以root为根的树呢？ 我们固定一个左孩子，遍历右子树列表，那么以当前为root根结点的树个数就为left.size() * right.size()个。 class Solution { public List generateTrees(int n) { if(n (); return helper(1, n); } public List helper(int start, int end){ List list = new ArrayList<>(); if(start > end){ // 如果当前子树为空，不加null行吗？ list.add(null); return list; } for(int i = start; i left = helper(start, i-1); List right = helper(i+1, end); // 固定左孩子，遍历右孩子 for(TreeNode l : left){ for(TreeNode r : right){ TreeNode root = new TreeNode(i); root.left = l; root.right = r; list.add(root); } } } return list; } } 值得注意的问题 关于TreeNode root = new TreeNode(i)的放置的位置问题，如果放在注释那行，那么每次从left,right列表摘一个TreeNode出来时，放在的都是同一个root下，这样该root(i)只会有num 棵相同的树（num = left.size() * right.size() > 1） 当前子树为空则必须要加null 显然，如果一颗树的左子树为空，右子树不为空，要正确构建所有树，依赖于对左右子树列表的遍历，也就是上述代码两层for循环的地方，如果其中一个列表为空，那么循环都将无法进行。(list.size==1) 每棵树的根节点在递归是start都与end相同，如helper(1,1),helper(2,2),helper(3,3),会用这个值生成一个根节点并装在list中返回回去(list.size==1),作为上一级方法中根节点的left列表或right列表 "},"leetcode-96-不同的二叉搜索树.html":{"url":"leetcode-96-不同的二叉搜索树.html","title":"leetcode96 不同的二叉搜索树","keywords":"","body":"给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？示例: 思路 假设n个节点存在二叉排序树的个数是G(n)G(n)G(n),令f(i)f(i)f(i)为以iii为根的二叉搜索树的个数，则： G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)G(n) = f(1)+f(2)+f(3)+f(4)+...+f(n)G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)  当iii为根节点时，其左子树节点个数为i−1i-1i−1个，右子树节点为n−in-in−i个，则： f(i)=G(i−1)∗G(n−i)f(i) = G(i-1)*G(n-i)f(i)=G(i−1)∗G(n−i)  综合可得卡特兰数的公式： G(n)=G(0)∗G(n−1)+G(1)∗G(n−2)+...+G(n−1)∗G(0)G(n) = G(0)*G(n-1) + G(1)*G(n-2)+...+G(n-1)*G(0)G(n)=G(0)∗G(n−1)+G(1)∗G(n−2)+...+G(n−1)∗G(0) class Solution { public int numTrees(int n) { int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for(int i=2;i "},"leetcode-98-验证二叉搜索树.html":{"url":"leetcode-98-验证二叉搜索树.html","title":"leetcode98 验证二叉搜索树","keywords":"","body":"给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 示例 2: 输入: 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 思路 考察二叉搜索树的特征：将二叉搜索树中序遍历则为升序。 因此做一个简单的中序遍历，在进行中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果当前节点的值大于前一个节点的值，则满足BST，将代表之前的变量pre赋值为该节点，否则直接返回false class Solution { int pre = Integer.MIN_VALUE; public boolean isValidBST(TreeNode root) { if(root == null) return true; if(!isValidBST(root.left)) return false; if(root.val java中各类型的最小最大值 注意到该题中使用了类型最小值来作为curr变量的初始值，最常使用到的是Integer类型下的MAX和MIN,格式为Integer.Max_VALUE,Integer.MIN_VALUE 而测试用例中（69/75）使用了[-2147483648]，是MIN_VALUE的值,导致了无法通过。因此初始值开到了Long.MIN_VALUE,不同类型下MAX和MIN格式是相通的 "},"leetcode-100-相同的树.html":{"url":"leetcode-100-相同的树.html","title":"leetcode100 相同的树","keywords":"","body":"给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 示例 2: 示例 3: 思路 class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if(p==null&&q==null){ return true; } else if(p==null||q==null){ return false; } else if(p.val != q.val){ return false; } return isSameTree(p.left,q.left) && isSameTree(p.right,q.right); } } 原理其实相当简单递归的判断两个节点，要么都为空，要么都不为空且值相等，这样递归到将两棵树比较结束。 这里还是看一下labuladong的文章写树算法的套路框架,特别要注意框架思维,如二叉树算法的设计的总路线： void traverse(TreeNode root) { // root 需要做什么？在这做。 // 其他的不用 root 操心，抛给框架 traverse(root.left); traverse(root.right); } 以及BST遍历的框架： void BST(TreeNode root, int target) { if (root.val == target) // 找到目标，做点什么 if (root.val target) BST(root.left, target); } "},"leetcode-101-对称二叉树.html":{"url":"leetcode-101-对称二叉树.html","title":"leetcode101 对称二叉树","keywords":"","body":"给定一个二叉树，检查它是否是镜像对称的 例如，二叉树 [1,2,2,3,4,4,3] 是对称的 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 思路 评论里这位老哥说的很好： 递归的难点在于：找到可以递归的点 为什么很多人觉得递归一看就会，一写就废。 或者说是自己写无法写出来，关键就是你对递归理解的深不深。 对于此题： 递归的点怎么找？从拿到题的第一时间开始，思路如下： 1.怎么判断一棵树是不是对称二叉树？ 答案：如果所给根节点，为空，那么是对称。如果不为空的话，当他的左子树与右子树对称时，他对称 2.那么怎么知道左子树与右子树对不对称呢？在这我直接叫为左树和右树 答案：如果左树的左孩子与右树的右孩子对称，左树的右孩子与右树的左孩子对称，那么这个左树和右树就对称。 仔细读这句话，是不是有点绕？怎么感觉有一个功能A我想实现，但我去实现A的时候又要用到A实现后的功能呢？ 当你思考到这里的时候，递归点已经出现了： 递归点：我在尝试判断左树与右树对称的条件时，发现其跟两树的孩子的对称情况有关系。 想到这里，你不必有太多疑问，上手去按思路写代码，函数A（左树，右树）功能是返回是否对称 def 函数A（左树，右树）： 左树节点值等于右树节点值 且 函数A（左树的左子树，右树的右子树），函数A（左树的右子树，右树的左子树）均为真 才返回真 实现完毕。。。 写着写着。。。你就发现你写出来了。。。 class Solution { public boolean isSymmetric(TreeNode root) { if(root == null) return true; return helper(root.left,root.right); } public boolean helper(TreeNode left,TreeNode right){ if(left == null && right == null) return true; else if(left==null || right == null) return false; else if(left.val != right.val) return false; return helper(left.left,right.right) && helper(left.right,right.left); } } 注意这种思路下要跳出原来只给一个参数的局限，坚决定义辅助函数 "},"leetcode-102，103，107-二叉树的层次遍历组题.html":{"url":"leetcode-102，103，107-二叉树的层次遍历组题.html","title":"leetcode102，103，107 二叉树的层次遍历组题","keywords":"","body":"leetcode 102,103,107本质上是一道题，故放在一起 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 leetcode 102 示例 二叉树：[3,9,20,null,null,15,7] 返回其层次遍历结果： 思路 很典型的bfs的应用，使用一个队列，bfs的模板如下： void bfs(TreeNode root) { Queue queue = new ArrayDeque<>(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); // Java 的 pop 写作 poll() if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } 而对于这道题，需要在每一层遍历开始前，使用一个变量来记录队列中的数量n(对应这一层的节点数量)，然后一口气处理完这一层的n个节点。 public List> levelOrder(TreeNode root) { List> res = new ArrayList<>(); Queue queue = new ArrayDeque<>(); if (root != null) { queue.add(root); } while (!queue.isEmpty()) { int n = queue.size(); List level = new ArrayList<>(); for (int i = 0; i 其中注意在每一轮遍历前都要将list清空 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树 [3,9,20,null,null,15,7] 返回锯齿形层次遍历如下： leetcode 103 解题思路 与leetcode 102题本质上相同，只是增加一个标志位flag,每次翻转来影响节点入list的顺序 class Solution { public List> zigzagLevelOrder(TreeNode root) { List> res = new ArrayList<>(); List list = null; if(root==null){ return res; } int flag = 1; Queue queue = new LinkedList<>(); queue.offer(root); while(!queue.isEmpty()){ int size = queue.size(); list = new ArrayList<>(); while(flag==1 && size>0){ TreeNode curr = queue.poll(); list.add(curr.val); if(curr.left!=null){ queue.offer(curr.left); } if(curr.right!=null){ queue.offer(curr.right); } size --; } while(flag==-1 && size>0){ TreeNode curr = queue.poll(); list.add(0,curr.val); if(curr.left!=null){ queue.offer(curr.left); } if(curr.right!=null){ queue.offer(curr.right); } size --; } res.add(list); flag *= -1; } return res; } } leetcode 107 解题思路 和之前几乎一致，就是在list插入res时从头部插入 class Solution { public List> levelOrderBottom(TreeNode root) { List> res = new ArrayList<>(); if(root==null){ return res; } List list = null; Queue queue = new LinkedList<>(); queue.offer(root); while(!queue.isEmpty()){ int size = queue.size(); list = new LinkedList<>(); while(size>0){ TreeNode curr = queue.poll(); list.add(curr.val); if(curr.left!=null){ queue.offer(curr.left); } if(curr.right!=null){ queue.offer(curr.right); } size --; } res.add(0,list); } return res; } } "},"leetcode-105,106-重建二叉树.html":{"url":"leetcode-105,106-重建二叉树.html","title":"leetcode-105,106 重建二叉树","keywords":"","body":"首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。 leetcode 105 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 思路 preorder第一个元素为root，在inorder里面找到root，在它之前的为左子树（长l1），之后为右子树（长l2）。preorder[1]到preorder[l1]为左子树,之后为右子树，分别递归。 //缺张图 class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return buildTreeHelper(preorder,0,preorder.length,inorder,0,inorder.length); } private TreeNode buildTreeHelper(int[] preorder,int p_start,int p_end,int[] inorder,int i_start,int i_end){ if(p_start == p_end){ return null; } int root_val = preorder[p_start]; TreeNode root = new TreeNode(root_val); int i_root_index = 0; for(int i=0;i "},"leetcode-701-二叉搜索树中的插入操作.html":{"url":"leetcode-701-二叉搜索树中的插入操作.html","title":"leetcode701 二叉搜索树中的插入操作","keywords":"","body":"给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 思路 如同leetcode100中说的，要利用BST的算法框架： void BST(TreeNode root, int target) { if (root.val == target) // 找到目标，做点什么 if (root.val target) BST(root.left, target); } 而看看回答，会发现就是按照这个模板来的： class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if(root==null) return new TreeNode(val); if(valroot.val) root.right = insertIntoBST(root.right,val); return root; } } "}}